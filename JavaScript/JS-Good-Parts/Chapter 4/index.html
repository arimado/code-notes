

<script> 

// function invocation + this workaround 

// var myObject = {six: 6};


// myObject.double = function () {
// 	console.log(this); 

// 	var that = this;

// 	var helper = function () {
// 		console.log(this); 
// 		console.log('that = ' + that.six); 
// 	}

// 	helper(); 
// } 

// myObject.double(); 


// //constructor
// var Quo = function (string) {
// 	this.status = string;
// 	this.value = 'string';  
// }

// //method - this is bound to object that invoked it 
// Quo.get_this = function () {
// 	return this; 
// }

// console.log('this Class')
// console.log(Quo.get_this());
// console.log('-----------------')

// //public method 
// Quo.prototype.get_status = function () {
// 	return this.status; 
// };

// Quo.prototype.get_this = function() {
// 	return this; 
// };

// console.log('this prototype')
// console.log(Quo.prototype.get_this());
// console.log('-----------------')


// var myQuo = new Quo("confused"); 

// console.log(myQuo.get_status()); 
// console.log(myQuo.get_this());
// console.log('-----------------')

// myQuo.get_this = function() {
// 	return this; 
// }; 

// console.log(myQuo.get_this()); 



// // what this is in the constroctor, the prototype 
// 	// contrsuctor --- 
// 		// 

// // what the new keyword does as well

// // --------------------------------

// var myObject = {
// 	value: 0; 
// 	increment: function (inc) {
// 		this.value += typeof inc === 'number' ? inc : 1; 
// 	}
// }

// myObject.increment(); // 1
// myObject.increment(); // 2

// // 27 January --------------------------------

Function.prototype.method = function (name, func) {
	this.prototype[name] = func; 
	return this; 
}

Number












</script> 